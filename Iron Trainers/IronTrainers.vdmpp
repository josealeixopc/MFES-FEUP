class IronTrainers
types
	public String = seq of char;
	
values
-- TODO Define values here

instance variables
	clients : set of Client;
	trainers : set of Trainer;
	allUsers : set of String;
	
operations

	public IronTrainers : () ==> IronTrainers
	IronTrainers() == (
		clients := {};
		trainers := {};
		allUsers := {};
	);
	
	-- Returns all users
	public getAllUsers : () ==> set of String
	getAllUsers() == return allUsers;
	
	-- Returns all registered clients
	public getClients : () ==> set of Client
	getClients() == return clients;
	
	-- Returns all trainers
	public getTrainers : () ==> set of Trainer
	getTrainers() == return trainers;

	-- Adds client to registered clients. If can't add client, it returns false
	public addClient : Client ==> ()
	addClient(client) == (
		clients := clients union {client};
		allUsers := allUsers union {client.getEmail()};
	)
	pre client not in set clients and client.getEmail() not in set allUsers
	post client in set clients;
		
	-- Removes client from registered clients
	public removeClient : Client ==> ()
	removeClient(client) == (
		clients := clients \ {client};
		allUsers := allUsers \ {client.getEmail()}
	)
	pre client in set clients and client.getEmail() in set allUsers
	post client not in set clients;
		
	-- Adds trainer to trainers. If can't add trainer, it returns false
	public addTrainer : Trainer ==> ()
	addTrainer(trainer) == (
		trainers := trainers union {trainer};
		allUsers := allUsers union {trainer.getEmail()};
	)
	pre trainer not in set trainers and trainer.getEmail() not in set allUsers
	post trainer in set trainers;
		
	-- Removes trainer from trainers
	public removeTrainer : Trainer ==> ()
	removeTrainer(trainer) ==
	(
		trainers := trainers \ {trainer};
		allUsers := allUsers \ {trainer.getEmail()};
	)
	pre ({trainer} subset trainers) = true and trainer.getEmail() in set allUsers
	post ({trainer} subset trainers) = false;
		
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end IronTrainers